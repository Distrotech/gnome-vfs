<MACRO>
<NAME>FNM_PATHNAME</NAME>
#define	FNM_PATHNAME	(1 << 0) /* No wildcard can ever match `/'.  */
</MACRO>
<MACRO>
<NAME>FNM_NOESCAPE</NAME>
#define	FNM_NOESCAPE	(1 << 1) /* Backslashes don't quote special chars.  */
</MACRO>
<MACRO>
<NAME>FNM_PERIOD</NAME>
#define	FNM_PERIOD	(1 << 2) /* Leading `.' is matched only explicitly.  */
</MACRO>
<MACRO>
<NAME>FNM_FILE_NAME</NAME>
#define	FNM_FILE_NAME	FNM_PATHNAME /* Preferred GNU name.  */
</MACRO>
<MACRO>
<NAME>FNM_LEADING_DIR</NAME>
#define	FNM_LEADING_DIR	(1 << 3) /* Ignore `/...' after a match.  */
</MACRO>
<MACRO>
<NAME>FNM_CASEFOLD</NAME>
#define	FNM_CASEFOLD	(1 << 4) /* Compare without regard to case.  */
</MACRO>
<MACRO>
<NAME>FNM_NOMATCH</NAME>
#define	FNM_NOMATCH	1
</MACRO>
<MACRO>
<NAME>GNOME_VFS_APPLICATION_REGISTRY_COMMAND</NAME>
#define GNOME_VFS_APPLICATION_REGISTRY_COMMAND "command"
</MACRO>
<MACRO>
<NAME>GNOME_VFS_APPLICATION_REGISTRY_NAME</NAME>
#define GNOME_VFS_APPLICATION_REGISTRY_NAME "name"
</MACRO>
<MACRO>
<NAME>GNOME_VFS_APPLICATION_REGISTRY_CAN_OPEN_MULTIPLE_FILES</NAME>
#define GNOME_VFS_APPLICATION_REGISTRY_CAN_OPEN_MULTIPLE_FILES "can_open_multiple_files"
</MACRO>
<MACRO>
<NAME>GNOME_VFS_APPLICATION_REGISTRY_CAN_OPEN_URIS</NAME>
#define GNOME_VFS_APPLICATION_REGISTRY_CAN_OPEN_URIS "can_open_uris"
</MACRO>
<MACRO>
<NAME>GNOME_VFS_APPLICATION_REGISTRY_REQUIRES_TERMINAL</NAME>
#define GNOME_VFS_APPLICATION_REGISTRY_REQUIRES_TERMINAL "requires_terminal"
</MACRO>
<FUNCTION>
<NAME>gnome_vfs_application_registry_exists</NAME>
<RETURNS>gboolean 	</RETURNS>
const char *app_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_get_keys</NAME>
<RETURNS>GList       	*</RETURNS>
const char *app_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_peek_value</NAME>
<RETURNS>const char  	*</RETURNS>
const char *app_id,const char *key
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_get_bool_value</NAME>
<RETURNS>gboolean 	</RETURNS>
const char *app_id,const char *key,gboolean *got_key
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_remove_application</NAME>
<RETURNS>void 	</RETURNS>
const char *app_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_set_value</NAME>
<RETURNS>void 	</RETURNS>
const char *app_id,const char *key,const char *value
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_set_bool_value</NAME>
<RETURNS>void 	</RETURNS>
const char *app_id,const char *key,gboolean value
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_unset_key</NAME>
<RETURNS>void 	</RETURNS>
const char *app_id,const char *key
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_get_applications</NAME>
<RETURNS>GList 		*</RETURNS>
const char *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_get_mime_types</NAME>
<RETURNS>GList 		*</RETURNS>
const char *app_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_supports_mime_type</NAME>
<RETURNS>gboolean 	</RETURNS>
const char *app_id,const char *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_clear_mime_types</NAME>
<RETURNS>void 	</RETURNS>
const char *app_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_add_mime_type</NAME>
<RETURNS>void 	</RETURNS>
const char *app_id,const char *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_remove_mime_type</NAME>
<RETURNS>void 	</RETURNS>
const char *app_id,const char *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_sync</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_shutdown</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_reload</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_get_mime_application</NAME>
<RETURNS>GnomeVFSMimeApplication  *</RETURNS>
const char *app_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_application_registry_save_mime_application</NAME>
<RETURNS>void 	</RETURNS>
const GnomeVFSMimeApplication *application
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_cancel</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSAsyncHandle *handle
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_open</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle **handle_return,const gchar *text_uri,GnomeVFSOpenMode open_mode,GnomeVFSAsyncOpenCallbackcallback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_open_uri</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle **handle_return,GnomeVFSURI *uri,GnomeVFSOpenMode open_mode,GnomeVFSAsyncOpenCallbackcallback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_open_as_channel</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle **handle_return,const gchar *text_uri,GnomeVFSOpenMode open_mode,guint advised_block_size,GnomeVFSAsyncOpenAsChannelCallbackcallback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_open_uri_as_channel</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle **handle_return,GnomeVFSURI *uri,GnomeVFSOpenMode open_mode,guint advised_block_size,GnomeVFSAsyncOpenAsChannelCallbackcallback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_create</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle **handle_return,const gchar *text_uri,GnomeVFSOpenMode open_mode,gboolean exclusive,guint perm,GnomeVFSAsyncOpenCallbackcallback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_create_uri</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle **handle_return,GnomeVFSURI *uri,GnomeVFSOpenMode open_mode,gboolean exclusive,guint perm,GnomeVFSAsyncOpenCallbackcallback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_create_symbolic_link</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle **handle_return,GnomeVFSURI *uri,const gchar *uri_reference,GnomeVFSAsyncOpenCallback callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_create_as_channel</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle **handle_return,const gchar *text_uri,GnomeVFSOpenMode open_mode,gboolean exclusive,guint perm,GnomeVFSAsyncCreateAsChannelCallbackcallback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_create_uri_as_channel</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle **handle_return,GnomeVFSURI *uri,GnomeVFSOpenMode open_mode,gboolean exclusive,guint perm,GnomeVFSAsyncCreateAsChannelCallbackcallback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_close</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle *handle,GnomeVFSAsyncCloseCallbackcallback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_read</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle *handle,gpointer buffer,guint bytes,GnomeVFSAsyncReadCallbackcallback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_write</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle *handle,gconstpointer buffer,guint bytes,GnomeVFSAsyncWriteCallbackcallback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_get_file_info</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle **handle_return,GList *uri_list,GnomeVFSFileInfoOptions options,GnomeVFSAsyncGetFileInfoCallback callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_set_file_info</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle **handle_return,GnomeVFSURI *uri,GnomeVFSFileInfo *info,GnomeVFSSetFileInfoMask mask,GnomeVFSFileInfoOptions options,GnomeVFSAsyncSetFileInfoCallback callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_load_directory</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle **handle_return,const gchar *text_uri,GnomeVFSFileInfoOptionsoptions,GnomeVFSDirectorySortRulesort_rules[],gboolean reverse_order,GnomeVFSDirectoryFilterTypefilter_type,GnomeVFSDirectoryFilterOptionsfilter_options,const gchar *filter_pattern,guint items_per_notification,GnomeVFSAsyncDirectoryLoadCallbackcallback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_load_directory_uri</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle **handle_return,GnomeVFSURI *uri,GnomeVFSFileInfoOptionsoptions,GnomeVFSDirectorySortRulesort_rules[],gboolean reverse_order,GnomeVFSDirectoryFilterTypefilter_type,GnomeVFSDirectoryFilterOptionsfilter_options,const gchar *filter_pattern,guint items_per_notification,GnomeVFSAsyncDirectoryLoadCallbackcallback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_xfer</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSAsyncHandle **handle_return,const GList *source_uri_list,const GList *target_uri_list,GnomeVFSXferOptionsxfer_options,GnomeVFSXferErrorModeerror_mode,GnomeVFSXferOverwriteModeoverwrite_mode,GnomeVFSAsyncXferProgressCallbackprogress_update_callback,gpointer update_callback_data,GnomeVFSXferProgressCallbackprogress_sync_callback,gpointer sync_callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_find_directory</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSAsyncHandle **handle_return,GList *near_uri_list,GnomeVFSFindDirectoryKind kind,gboolean create_if_needed,gboolean find_if_needed,guint permissions,GnomeVFSAsyncFindDirectoryCallback callback,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_add_status_callback</NAME>
<RETURNS>guint  </RETURNS>
GnomeVFSAsyncHandle *handle,GnomeVFSStatusCallback callback,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_async_remove_status_callback</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSAsyncHandle *handle,guint callback_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_backend_loadinit</NAME>
<RETURNS>void  </RETURNS>
gpointer app,gpointer modinfo
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_backend_name</NAME>
<RETURNS>const char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_backend_init</NAME>
<RETURNS>gboolean  </RETURNS>
gboolean init_deps
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_backend_shutdown</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_backend_get_job_count</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_open_uri_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSHandle **handle,GnomeVFSURI *uri,GnomeVFSOpenMode open_mode,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_create_uri_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSHandle **handle,GnomeVFSURI *uri,GnomeVFSOpenMode open_mode,gboolean exclusive,guint perm,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_close_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSHandle *handle,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_read_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSHandle *handle,gpointer buffer,GnomeVFSFileSize bytes,GnomeVFSFileSize *bytes_written,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_write_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSHandle *handle,gconstpointer buffer,GnomeVFSFileSize bytes,GnomeVFSFileSize *bytes_written,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_seek_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSHandle *handle,GnomeVFSSeekPosition whence,GnomeVFSFileOffset offset,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_file_info_uri_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *uri,GnomeVFSFileInfo *info,GnomeVFSFileInfoOptions options,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_file_info_from_handle_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSHandle *handle,GnomeVFSFileInfo *info,GnomeVFSFileInfoOptions options,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_truncate_uri_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *uri,GnomeVFSFileSize length,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_truncate_handle_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSHandle *handle,GnomeVFSFileSize length,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_make_directory_for_uri_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *uri,guint perm,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_find_directory_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *near_uri,GnomeVFSFindDirectoryKind kind,GnomeVFSURI **result_uri,gboolean create_if_needed,gboolean find_if_needed,guint permissions,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_remove_directory_from_uri_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *uri,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_unlink_from_uri_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *uri,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_create_symbolic_link_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *uri,const gchar *target_reference,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_move_uri_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *old,GnomeVFSURI *new,gboolean force_replace,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_check_same_fs_uris_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *a,GnomeVFSURI *b,gboolean *same_fs_return,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_set_file_info_cancellable</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *a,const GnomeVFSFileInfo *info,GnomeVFSSetFileInfoMask mask,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_xfer_private</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const GList *source_uri_list,const GList *target_uri_list,GnomeVFSXferOptions xfer_options,GnomeVFSXferErrorMode error_mode,GnomeVFSXferOverwriteMode overwrite_mode,GnomeVFSXferProgressCallback progress_callback,gpointer data,GnomeVFSXferProgressCallback sync_progress_callback,gpointer sync_progress_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_cancellation_new</NAME>
<RETURNS>GnomeVFSCancellation  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_cancellation_destroy</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSCancellation *cancellation
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_cancellation_cancel</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSCancellation *cancellation
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_cancellation_check</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeVFSCancellation *cancellation
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_cancellation_ack</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSCancellation *cancellation
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_cancellation_get_fd</NAME>
<RETURNS>gint 	</RETURNS>
GnomeVFSCancellation *cancellation
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_configuration_add_directory</NAME>
<RETURNS>void  </RETURNS>
const char *dir
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_configuration_init</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_configuration_uninit</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_configuration_get_module_path</NAME>
<RETURNS>const gchar  *</RETURNS>
const gchar *method_name, const char ** args
</FUNCTION>
<MACRO>
<NAME>GNOME_VFS_URI_MAGIC_CHR</NAME>
#define GNOME_VFS_URI_MAGIC_CHR	'#'
</MACRO>
<MACRO>
<NAME>GNOME_VFS_URI_MAGIC_STR</NAME>
#define GNOME_VFS_URI_MAGIC_STR "#"
</MACRO>
<MACRO>
<NAME>GNOME_VFS_URI_PATH_CHR</NAME>
#define GNOME_VFS_URI_PATH_CHR '/'
</MACRO>
<MACRO>
<NAME>GNOME_VFS_URI_PATH_STR</NAME>
#define GNOME_VFS_URI_PATH_STR "/"
</MACRO>
<FUNCTION>
<NAME>gnome_vfs_context_new</NAME>
<RETURNS>GnomeVFSContext *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_context_ref</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_context_unref</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_context_get_message_callbacks</NAME>
<RETURNS>GnomeVFSMessageCallbacks *</RETURNS>
GnomeVFSContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_context_get_cancellation</NAME>
<RETURNS>GnomeVFSCancellation *</RETURNS>
GnomeVFSContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_context_get_redirect_uri</NAME>
<RETURNS>const gchar *</RETURNS>
GnomeVFSContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_context_set_redirect_uri</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSContext *ctx,const gchar     *uri
</FUNCTION>
<MACRO>
<NAME>gnome_vfs_context_check_cancellation</NAME>
#define          gnome_vfs_context_check_cancellation(x) (gnome_vfs_cancellation_check((x) ? gnome_vfs_context_get_cancellation((x)) : NULL))
</MACRO>
<FUNCTION>
<NAME>gnome_vfs_context_emit_message</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSContext *ctx,const gchar* message
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_filter_new</NAME>
<RETURNS>GnomeVFSDirectoryFilter  *</RETURNS>
GnomeVFSDirectoryFilterType type,GnomeVFSDirectoryFilterOptionsoptions,const gchar *filter_pattern
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_filter_destroy</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSDirectoryFilter *filter
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_new</NAME>
<RETURNS>GnomeVFSDirectoryList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_destroy</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSDirectoryList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_prepend</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSDirectoryList *list,GnomeVFSFileInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_append</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSDirectoryList *list,GnomeVFSFileInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_filter</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSDirectoryList *list,GnomeVFSDirectoryFilter*filter
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_sort</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSDirectoryList *list,gboolean reversed,const GnomeVFSDirectorySortRule*rules
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_sort_custom</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSDirectoryList *list,GnomeVFSDirectorySortFunccompare_func,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_first</NAME>
<RETURNS>GnomeVFSFileInfo  *</RETURNS>
GnomeVFSDirectoryList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_next</NAME>
<RETURNS>GnomeVFSFileInfo  *</RETURNS>
GnomeVFSDirectoryList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_prev</NAME>
<RETURNS>GnomeVFSFileInfo  *</RETURNS>
GnomeVFSDirectoryList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_last</NAME>
<RETURNS>GnomeVFSFileInfo  *</RETURNS>
GnomeVFSDirectoryList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_current</NAME>
<RETURNS>GnomeVFSFileInfo  *</RETURNS>
GnomeVFSDirectoryList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_nth</NAME>
<RETURNS>GnomeVFSFileInfo  *</RETURNS>
GnomeVFSDirectoryList *list,guint n
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_get</NAME>
<RETURNS>GnomeVFSFileInfo  *</RETURNS>
GnomeVFSDirectoryList *list,GnomeVFSDirectoryListPositionposition
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_get_num_entries</NAME>
<RETURNS>guint 	</RETURNS>
GnomeVFSDirectoryList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_get_position</NAME>
<RETURNS>GnomeVFSDirectoryListPosition</RETURNS>
GnomeVFSDirectoryList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_set_position</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSDirectoryList *list,GnomeVFSDirectoryListPositionposition
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_position_next</NAME>
<RETURNS>GnomeVFSDirectoryListPosition</RETURNS>
GnomeVFSDirectoryListPositionposition
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_position_prev</NAME>
<RETURNS>GnomeVFSDirectoryListPosition</RETURNS>
GnomeVFSDirectoryListPositionposition
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_load</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSDirectoryList **list,const gchar *uri,GnomeVFSFileInfoOptions options,const GnomeVFSDirectoryFilter *filter
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_list_load_from_uri</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSDirectoryList **list,GnomeVFSURI *uri,GnomeVFSFileInfoOptions options,const GnomeVFSDirectoryFilter *filter
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_open</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSDirectoryHandle **handle,const gchar *text_uri,GnomeVFSFileInfoOptions options,const GnomeVFSDirectoryFilter *filter
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_open_from_uri</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSDirectoryHandle **handle,GnomeVFSURI *uri,GnomeVFSFileInfoOptions options,const GnomeVFSDirectoryFilter *filter
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_read_next</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSDirectoryHandle *handle,GnomeVFSFileInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_close</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSDirectoryHandle *handle
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_visit</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const gchar *uri,GnomeVFSFileInfoOptions info_options,const GnomeVFSDirectoryFilter *filter,GnomeVFSDirectoryVisitOptionsvisit_options,GnomeVFSDirectoryVisitFunc callback,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_visit_uri</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *uri,GnomeVFSFileInfoOptions info_options,const GnomeVFSDirectoryFilter *filter,GnomeVFSDirectoryVisitOptionsvisit_options,GnomeVFSDirectoryVisitFunc callback,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_visit_files</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
const gchar *text_uri,GList *file_list,GnomeVFSFileInfoOptions info_options,const GnomeVFSDirectoryFilter *filter,GnomeVFSDirectoryVisitOptionsvisit_options,GnomeVFSDirectoryVisitFunc callback,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_directory_visit_files_at_uri</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSURI *uri,GList *file_list,GnomeVFSFileInfoOptions info_options,const GnomeVFSDirectoryFilter *filter,GnomeVFSDirectoryVisitOptionsvisit_options,GnomeVFSDirectoryVisitFunc callback,gpointer data
</FUNCTION>
<MACRO>
<NAME>GNOME_VFS_FILE_INFO_SYMLINK</NAME>
#define GNOME_VFS_FILE_INFO_SYMLINK(info)		\
	((info)->flags & GNOME_VFS_FILE_FLAGS_SYMLINK)
</MACRO>
<MACRO>
<NAME>GNOME_VFS_FILE_INFO_SET_SYMLINK</NAME>
#define GNOME_VFS_FILE_INFO_SET_SYMLINK(info, value)			\
	(value ? ((info)->flags |= GNOME_VFS_FILE_FLAGS_SYMLINK)	\
	       : ((info)->flags &= ~GNOME_VFS_FILE_FLAGS_SYMLINK))
</MACRO>
<MACRO>
<NAME>GNOME_VFS_FILE_INFO_LOCAL</NAME>
#define GNOME_VFS_FILE_INFO_LOCAL(info)			\
	((info)->flags & GNOME_VFS_FILE_FLAGS_LOCAL)
</MACRO>
<MACRO>
<NAME>GNOME_VFS_FILE_INFO_SET_LOCAL</NAME>
#define GNOME_VFS_FILE_INFO_SET_LOCAL(info, value)			\
	(value ? ((info)->flags |= GNOME_VFS_FILE_FLAGS_LOCAL)		\
	       : ((info)->flags &= ~GNOME_VFS_FILE_FLAGS_LOCAL))
</MACRO>
<MACRO>
<NAME>GNOME_VFS_FILE_INFO_SUID</NAME>
#define GNOME_VFS_FILE_INFO_SUID(info)			\
	((info)->permissions & GNOME_VFS_PERM_SUID)
</MACRO>
<MACRO>
<NAME>GNOME_VFS_FILE_INFO_SGID</NAME>
#define GNOME_VFS_FILE_INFO_SGID(info)			\
	((info)->permissions & GNOME_VFS_PERM_SGID)
</MACRO>
<MACRO>
<NAME>GNOME_VFS_FILE_INFO_STICKY</NAME>
#define GNOME_VFS_FILE_INFO_STICKY(info)		\
	((info)->permissions & GNOME_VFS_PERM_STICKY)
</MACRO>
<MACRO>
<NAME>GNOME_VFS_FILE_INFO_SET_SUID</NAME>
#define GNOME_VFS_FILE_INFO_SET_SUID(info, value)		\
	(value ? ((info)->permissions |= GNOME_VFS_PERM_SUID)	\
	       : ((info)->permissions &= ~GNOME_VFS_PERM_SUID))
</MACRO>
<MACRO>
<NAME>GNOME_VFS_FILE_INFO_SET_SGID</NAME>
#define GNOME_VFS_FILE_INFO_SET_SGID(info, value)		\
	(value ? ((info)->permissions |= GNOME_VFS_PERM_SGID)	\
	       : ((info)->permissions &= ~GNOME_VFS_PERM_SGID))
</MACRO>
<MACRO>
<NAME>GNOME_VFS_FILE_INFO_SET_STICKY</NAME>
#define GNOME_VFS_FILE_INFO_SET_STICKY(info, value)			\
	(value ? ((info)->permissions |= GNOME_VFS_PERM_STICKY)		\
	       : ((info)->permissions &= ~GNOME_VFS_PERM_STICKY))
</MACRO>
<FUNCTION>
<NAME>gnome_vfs_file_info_new</NAME>
<RETURNS>GnomeVFSFileInfo  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_init</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSFileInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_clear</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSFileInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_unref</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSFileInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_ref</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSFileInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_get_mime_type</NAME>
<RETURNS>const gchar 	*</RETURNS>
GnomeVFSFileInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_copy</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSFileInfo *dest,const GnomeVFSFileInfo *src
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_dup</NAME>
<RETURNS>GnomeVFSFileInfo  *</RETURNS>
const GnomeVFSFileInfo *orig
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_matches</NAME>
<RETURNS>gboolean 	</RETURNS>
const GnomeVFSFileInfo *a,const GnomeVFSFileInfo *b
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_compare_for_sort</NAME>
<RETURNS>gint 	</RETURNS>
const GnomeVFSFileInfo *a,const GnomeVFSFileInfo *b,const GnomeVFSDirectoryFilterType *sort_rules
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_compare_for_sort_reversed</NAME>
<RETURNS>gint 	</RETURNS>
const GnomeVFSFileInfo *a,const GnomeVFSFileInfo *b,const GnomeVFSDirectoryFilterType *sort_rules
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_list_ref</NAME>
<RETURNS>GList            *</RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_list_unref</NAME>
<RETURNS>GList            *</RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_list_copy</NAME>
<RETURNS>GList            *</RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_file_info_list_free</NAME>
<RETURNS>void  </RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_find_directory</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSURI 			*near_uri,GnomeVFSFindDirectoryKind 	kind,GnomeVFSURI 			**result,gboolean 			create_if_needed,gboolean			find_if_needed,guint 			permissions
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_handle_new</NAME>
<RETURNS>GnomeVFSHandle  *</RETURNS>
GnomeVFSURI *uri,GnomeVFSMethodHandle*method_handle,GnomeVFSOpenMode open_mode
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_handle_destroy</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSHandle *handle
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_handle_get_open_mode</NAME>
<RETURNS>GnomeVFSOpenMode</RETURNS>
GnomeVFSHandle *handle
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_handle_do_close</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle *handle,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_handle_do_read</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle *handle,gpointer buffer,GnomeVFSFileSize num_bytes,GnomeVFSFileSize *bytes_read,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_handle_do_write</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle *handle,gconstpointer buffer,GnomeVFSFileSize num_bytes,GnomeVFSFileSize *bytes_written,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_handle_do_close_directory</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle *handle,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_handle_do_read_directory</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle *handle,GnomeVFSFileInfo *file_info,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_handle_do_seek</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle *handle,GnomeVFSSeekPosition whence,GnomeVFSFileSize offset,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_handle_do_tell</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle *handle,GnomeVFSFileSize *offset_return
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_handle_do_get_file_info</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSHandle *handle,GnomeVFSFileInfo *info,GnomeVFSFileInfoOptions options,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_handle_do_truncate</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSHandle *handle,GnomeVFSFileSize length,GnomeVFSContext *context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_inet_connection_create</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSInetConnection **connection_return,const gchar *host_name,guint host_port,GnomeVFSCancellation *cancellation
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_inet_connection_destroy</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSInetConnection *connection,GnomeVFSCancellation *cancellation
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_inet_connection_get_iobuf</NAME>
<RETURNS>GnomeVFSIOBuf 	*</RETURNS>
GnomeVFSInetConnection *connection
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_init</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_initialized</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_shutdown</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_loadinit</NAME>
<RETURNS>void  </RETURNS>
gpointer app, gpointer modinfo
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_preinit</NAME>
<RETURNS>void  </RETURNS>
gpointer app, gpointer modinfo
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_postinit</NAME>
<RETURNS>void  </RETURNS>
gpointer app, gpointer modinfo
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_iobuf_new</NAME>
<RETURNS>GnomeVFSIOBuf    *</RETURNS>
gint fd
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_iobuf_destroy</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSIOBuf *iobuf
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_iobuf_read</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSIOBuf *iobuf,gpointer buffer,GnomeVFSFileSize bytes,GnomeVFSFileSize *bytes_read
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_iobuf_peekc</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSIOBuf *iobuf,gchar *c
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_iobuf_write</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSIOBuf *iobuf,gconstpointer buffer,GnomeVFSFileSize bytes,GnomeVFSFileSize *bytes_written
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_iobuf_flush</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSIOBuf *iobuf
</FUNCTION>
<USER_FUNCTION>
<NAME>GnomeVFSListCompareFunc</NAME>
<RETURNS>gint </RETURNS>
gconstpointer a, gconstpointer b,
					  gpointer data
</USER_FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_list_sort</NAME>
<RETURNS>GList  *</RETURNS>
GList *list,GnomeVFSListCompareFunc compare_func,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_message_callbacks_new</NAME>
<RETURNS>GnomeVFSMessageCallbacks *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_message_callbacks_destroy</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSMessageCallbacks *cbs
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_message_callbacks_add</NAME>
<RETURNS>guint  </RETURNS>
GnomeVFSMessageCallbacks *cbs,GnomeVFSStatusCallback    callback,gpointer                  user_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_message_callbacks_add_full</NAME>
<RETURNS>guint  </RETURNS>
GnomeVFSMessageCallbacks *cbs,GnomeVFSStatusCallback    callback,gpointer                  user_data,GDestroyNotify            notify
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_message_callbacks_remove</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSMessageCallbacks *cbs,guint num
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_message_callbacks_remove_by_func</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSMessageCallbacks *cbs,GnomeVFSStatusCallback    callback
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_message_callbacks_remove_by_data</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSMessageCallbacks *cbs,gpointer                  user_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_message_callbacks_remove_by_func_and_data</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSMessageCallbacks *cbs,GnomeVFSStatusCallback    callback,gpointer                  user_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_message_callbacks_emit</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSMessageCallbacks *cbs,const gchar              *message
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_method_init</NAME>
<RETURNS>gboolean 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_method_get</NAME>
<RETURNS>GnomeVFSMethod     *</RETURNS>
const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_transform_get</NAME>
<RETURNS>GnomeVFSTransform  *</RETURNS>
const gchar *name
</FUNCTION>
<ENUM>
<NAME>GnomeVFSMimeActionType</NAME>
typedef enum {
	GNOME_VFS_MIME_ACTION_TYPE_NONE,
	GNOME_VFS_MIME_ACTION_TYPE_APPLICATION,
	GNOME_VFS_MIME_ACTION_TYPE_COMPONENT
} GnomeVFSMimeActionType;
</ENUM>
<TYPEDEF>
<NAME>GnomeVFSMimeApplication</NAME>
typedef struct {
	char *id;
	char *name;
	char *command;
	gboolean can_open_multiple_files;
	gboolean can_open_uris;
	gboolean requires_terminal;
} GnomeVFSMimeApplication;
</TYPEDEF>
<TYPEDEF>
<NAME>GnomeVFSMimeAction</NAME>
typedef struct {
	GnomeVFSMimeActionType action_type;
	union {
		OAF_ServerInfo *component;
		void *dummy_component;
		GnomeVFSMimeApplication *application;
	} action;
} GnomeVFSMimeAction;
</TYPEDEF>
<FUNCTION>
<NAME>gnome_vfs_mime_application_copy</NAME>
<RETURNS>GnomeVFSMimeApplication  *</RETURNS>
GnomeVFSMimeApplication *application
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_default_action_type</NAME>
<RETURNS>GnomeVFSMimeActionType  </RETURNS>
const char              *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_default_action</NAME>
<RETURNS>GnomeVFSMimeAction  *</RETURNS>
const char              *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_default_action_without_fallback</NAME>
<RETURNS>GnomeVFSMimeAction  *</RETURNS>
const char              *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_default_application</NAME>
<RETURNS>GnomeVFSMimeApplication  *</RETURNS>
const char              *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_default_component</NAME>
<RETURNS>OAF_ServerInfo  *</RETURNS>
const char              *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_short_list_applications</NAME>
<RETURNS>GList  *</RETURNS>
const char              *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_short_list_components</NAME>
<RETURNS>GList  *</RETURNS>
const char              *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_all_applications</NAME>
<RETURNS>GList  *</RETURNS>
const char              *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_all_components</NAME>
<RETURNS>GList  *</RETURNS>
const char              *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_set_default_action_type</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char              *mime_type,GnomeVFSMimeActionType   action_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_set_default_application</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char              *mime_type,const char              *application_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_set_default_component</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char              *mime_type,const char              *component_iid
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_icon</NAME>
<RETURNS>const char   		*</RETURNS>
const char 		    *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_set_icon</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char 		    *mime_type,const char		    *filename
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_description</NAME>
<RETURNS>const char  	        *</RETURNS>
const char              *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_set_short_list_applications</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char              *mime_type,GList                   *application_ids
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_set_short_list_components</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char              *mime_type,GList                   *component_ids
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_add_application_to_short_list</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char              *uri,const char              *application_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_remove_application_from_short_list</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char              *uri,const char              *application_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_add_component_to_short_list</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char              *uri,const char              *iid
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_remove_component_from_short_list</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char              *uri,const char              *iid
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_add_extension</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char              *mime_type,const char              *extension
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_remove_extension</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char              *mime_type,const char              *extension
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_extend_all_applications</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char              *mime_type,GList                   *application_ids
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_remove_from_all_applications</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char              *mime_type,GList                   *application_ids
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_application_new_from_id</NAME>
<RETURNS>GnomeVFSMimeApplication  *</RETURNS>
const char              *id
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_application_free</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSMimeApplication *application
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_action_free</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSMimeAction      *action
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_application_list_free</NAME>
<RETURNS>void  </RETURNS>
GList                   *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_component_list_free</NAME>
<RETURNS>void  </RETURNS>
GList                   *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_id_in_application_list</NAME>
<RETURNS>gboolean  </RETURNS>
const char              *id,GList                   *applications
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_id_in_component_list</NAME>
<RETURNS>gboolean  </RETURNS>
const char              *iid,GList                   *components
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_remove_application_from_list</NAME>
<RETURNS>GList  *</RETURNS>
GList                   *applications,const char              *application_id,gboolean                *did_remove
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_remove_component_from_list</NAME>
<RETURNS>GList  *</RETURNS>
GList                   *components,const char              *iid,gboolean                *did_remove
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_id_list_from_component_list</NAME>
<RETURNS>GList  *</RETURNS>
GList                   *components
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_id_list_from_application_list</NAME>
<RETURNS>GList  *</RETURNS>
GList                   *applications
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_freeze</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_thaw</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_info_reload</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_value</NAME>
<RETURNS>const char  	*</RETURNS>
const char *mime_type,const char *key
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_set_value</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const char *mime_type,const char *key,const char *value
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_key_list</NAME>
<RETURNS>GList       	*</RETURNS>
const char *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_keys_list_free</NAME>
<RETURNS>void  </RETURNS>
GList *mime_ype_list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_extensions_list</NAME>
<RETURNS>GList  	   	*</RETURNS>
const char *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_extensions_list_free</NAME>
<RETURNS>void 	</RETURNS>
GList      *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_extensions_string</NAME>
<RETURNS>char  	   	*</RETURNS>
const char *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_get_extensions_pretty_string</NAME>
<RETURNS>char  	   	*</RETURNS>
const char *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_registered_mime_types</NAME>
<RETURNS>GList  	        *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_registered_mime_type_list_free</NAME>
<RETURNS>void 	</RETURNS>
GList      *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_set_registered_type_key</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
const char *mime_type,const char *key,const char *data
</FUNCTION>
<ENUM>
<NAME>GnomeMagicType</NAME>
typedef enum {
	T_END, /* end of array */
	T_BYTE,
	T_SHORT,
	T_LONG,
	T_STR,
	T_DATE, 
	T_BESHORT,
	T_BELONG,
	T_BEDATE,
	T_LESHORT,
	T_LELONG,
	T_LEDATE
} GnomeMagicType;
</ENUM>
<FUNCTION>
<NAME>gnome_vfs_mime_magic_parse</NAME>
<RETURNS>GnomeMagicEntry  *</RETURNS>
const gchar *filename, gint *nents
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_test_get_magic_table</NAME>
<RETURNS>GnomeMagicEntry  *</RETURNS>
const char *table_path
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_dump_magic_table</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_info_shutdown</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>GnomeVFSSniffBufferSeekCall</NAME>
<RETURNS>GnomeVFSResult </RETURNS>
gpointer context, 
		GnomeVFSSeekPosition whence, GnomeVFSFileOffset offset
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeVFSSniffBufferReadCall</NAME>
<RETURNS>GnomeVFSResult </RETURNS>
gpointer context, 
		gpointer buffer, GnomeVFSFileSize bytes, GnomeVFSFileSize *bytes_read
</USER_FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_clear_magic_table</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_sniff_buffer_new_from_handle</NAME>
<RETURNS>GnomeVFSMimeSniffBuffer 	*</RETURNS>
GnomeVFSHandle 		*file
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_sniff_buffer_new_from_memory</NAME>
<RETURNS>GnomeVFSMimeSniffBuffer 	*</RETURNS>
const guchar 			*buffer,ssize_t 			buffer_size
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_sniff_buffer_new_from_existing_data</NAME>
<RETURNS>GnomeVFSMimeSniffBuffer 	*</RETURNS>
const guchar 			*buffer,ssize_t 			buffer_size
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_sniff_buffer_new_generic</NAME>
<RETURNS>GnomeVFSMimeSniffBuffer 	*</RETURNS>
GnomeVFSSniffBufferSeekCall	seek_callback,GnomeVFSSniffBufferReadCall	read_callback,gpointer			context
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_sniff_buffer_free</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSMimeSniffBuffer	*buffer
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_sniff_buffer_get</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSMimeSniffBuffer	*buffer,ssize_t			size
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_mime_type_for_buffer</NAME>
<RETURNS>const char   		*</RETURNS>
GnomeVFSMimeSniffBuffer	*buffer
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_sniff_buffer_looks_like_text</NAME>
<RETURNS>gboolean 	</RETURNS>
GnomeVFSMimeSniffBuffer	*buffer
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_sniff_buffer_looks_like_mp3</NAME>
<RETURNS>gboolean 	</RETURNS>
GnomeVFSMimeSniffBuffer	*buffer
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_shutdown</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_type_from_name</NAME>
<RETURNS>const char   *</RETURNS>
const gchar* filename
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_type_from_name_or_default</NAME>
<RETURNS>const char   *</RETURNS>
const gchar *filename,const gchar *defaultv
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_mime_type</NAME>
<RETURNS>const char   *</RETURNS>
GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_mime_type_from_uri</NAME>
<RETURNS>const char   *</RETURNS>
GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_mime_type_from_file_data</NAME>
<RETURNS>const char   *</RETURNS>
GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_mime_type_for_data</NAME>
<RETURNS>const char   *</RETURNS>
gconstpointer data,int data_size
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_file_mime_type</NAME>
<RETURNS>const char   *</RETURNS>
const char *path,const struct stat *optional_stat_info,gboolean suffix_only
</FUNCTION>
<FUNCTION>
<NAME>gnome_uri_list_extract_filenames</NAME>
<RETURNS>GList        *</RETURNS>
const gchar* uri_list
</FUNCTION>
<FUNCTION>
<NAME>gnome_uri_list_extract_uris</NAME>
<RETURNS>GList        *</RETURNS>
const gchar* uri_list
</FUNCTION>
<FUNCTION>
<NAME>gnome_uri_list_free_strings</NAME>
<RETURNS>void  </RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_uri_extract_filename</NAME>
<RETURNS>gchar        *</RETURNS>
const gchar* uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_mime_type_from_mode</NAME>
<RETURNS>const gchar  *</RETURNS>
mode_t mode
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_stat_to_file_info</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSFileInfo *file_info,const struct stat *statptr
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_set_meta</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSFileInfo *info,const gchar *file_name,const gchar *meta_key
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_set_meta_for_list</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSFileInfo *info,const gchar *file_name,const GList *meta_keys
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_special_mime_type</NAME>
<RETURNS>const char     *</RETURNS>
GnomeVFSURI *uri
</FUNCTION>
<MACRO>
<NAME>GNOME_VFS_MODULE_INIT</NAME>
#define GNOME_VFS_MODULE_INIT      "vfs_module_init"
</MACRO>
<MACRO>
<NAME>GNOME_VFS_MODULE_TRANSFORM</NAME>
#define GNOME_VFS_MODULE_TRANSFORM "vfs_module_transform"
</MACRO>
<MACRO>
<NAME>GNOME_VFS_MODULE_SHUTDOWN</NAME>
#define GNOME_VFS_MODULE_SHUTDOWN  "vfs_module_shutdown"
</MACRO>
<FUNCTION>
<NAME>vfs_module_init</NAME>
<RETURNS>GnomeVFSMethod     *</RETURNS>
const char *method_name, const char *args
</FUNCTION>
<FUNCTION>
<NAME>vfs_module_transform</NAME>
<RETURNS>GnomeVFSTransform  *</RETURNS>
const char *method_name, const char *args
</FUNCTION>
<FUNCTION>
<NAME>vfs_module_shutdown</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSMethod *method
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_open</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle **handle,const gchar *text_uri,GnomeVFSOpenMode open_mode
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_open_uri</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle **handle,GnomeVFSURI *uri,GnomeVFSOpenMode open_mode
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_create</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle **handle,const gchar *text_uri,GnomeVFSOpenMode open_mode,gboolean exclusive,guint perm
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_create_uri</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle **handle,GnomeVFSURI *uri,GnomeVFSOpenMode open_mode,gboolean exclusive,guint perm
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_close</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSHandle *handle
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_read</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle *handle,gpointer buffer,GnomeVFSFileSize bytes,GnomeVFSFileSize *bytes_read
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_write</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle *handle,gconstpointer buffer,GnomeVFSFileSize bytes,GnomeVFSFileSize *bytes_written
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_seek</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle *handle,GnomeVFSSeekPosition whence,GnomeVFSFileOffset offset
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_tell</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle *handle,GnomeVFSFileSize *offset_return
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_file_info</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
const gchar *text_uri,GnomeVFSFileInfo *info,GnomeVFSFileInfoOptionsoptions
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_file_info_uri</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSURI *uri,GnomeVFSFileInfo *info,GnomeVFSFileInfoOptionsoptions
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_file_info_from_handle</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSHandle *handle,GnomeVFSFileInfo *info,GnomeVFSFileInfoOptionsoptions
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_truncate</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const gchar *text_uri,GnomeVFSFileSize length
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_truncate_uri</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *uri,GnomeVFSFileSize length
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_truncate_handle</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSHandle *handle,GnomeVFSFileSize length
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_make_directory_for_uri</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSURI *uri, guint perm
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_make_directory</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
const gchar *text_uri,guint perm
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_remove_directory_from_uri</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_remove_directory</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
const gchar *text_uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_unlink_from_uri</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_create_symbolic_link</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *uri,const gchar *target_reference
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_unlink</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const gchar *text_uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_move_uri</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *old_uri,GnomeVFSURI *new_uri,gboolean force_replace
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_move</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const gchar *old_text_uri,const gchar *new_text_uri,gboolean force_replace
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_check_same_fs_uris</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
GnomeVFSURI *a,GnomeVFSURI *b,gboolean *same_fs_return
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_check_same_fs</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
const gchar *a,const gchar *b,gboolean *same_fs_return
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_exists</NAME>
<RETURNS>gboolean 	</RETURNS>
GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_set_file_info_uri</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
GnomeVFSURI *uri,GnomeVFSFileInfo *info,GnomeVFSSetFileInfoMask mask
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_set_file_info</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const gchar *text_uri,GnomeVFSFileInfo *info,GnomeVFSSetFileInfoMask mask
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_parse_ls_lga</NAME>
<RETURNS>gint  </RETURNS>
const gchar *p, struct stat *s,gchar **filename, gchar **linkname
</FUNCTION>
<TYPEDEF>
<NAME>GnomeVFSMethodHandle</NAME>
typedef gpointer GnomeVFSMethodHandle;
</TYPEDEF>
<USER_FUNCTION>
<NAME>GnomeVFSMethodInitFunc</NAME>
<RETURNS>GnomeVFSMethod *</RETURNS>
const char *method_name, const char *config_args
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeVFSMethodShutdownFunc</NAME>
<RETURNS>void </RETURNS>
GnomeVFSMethod *method
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeVFSMethodTruncateFunc</NAME>
<RETURNS>GnomeVFSResult </RETURNS>
GnomeVFSMethod *method,
						       GnomeVFSURI *uri,
						       GnomeVFSFileSize length,
						       GnomeVFSContext *context
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeVFSMethodTruncateHandleFunc</NAME>
<RETURNS>GnomeVFSResult </RETURNS>
GnomeVFSMethod *method,
							     GnomeVFSMethodHandle *handle,
							     GnomeVFSFileSize length,
							     GnomeVFSContext *context
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeVFSTransformInitFunc</NAME>
<RETURNS>GnomeVFSTransform *</RETURNS>
const char *method_name, const char *config_args
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeVFSTransformFunc</NAME>
<RETURNS>GnomeVFSResult </RETURNS>
GnomeVFSTransform *transform,
						  const gchar *old_uri,
						  gchar **new_uri,
						  GnomeVFSContext *context
</USER_FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_canonicalize_pathname</NAME>
<RETURNS>gchar    	*</RETURNS>
gchar *path
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_forkexec</NAME>
<RETURNS>pid_t 	</RETURNS>
const gchar *file_name,const gchar * const argv[],GnomeVFSProcessOptions options,GnomeVFSProcessInitFunc init_func,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_create_temp</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
const gchar *prefix,gchar **name_return,GnomeVFSHandle **handle_return
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_atotm</NAME>
<RETURNS>gboolean 	</RETURNS>
const gchar *time_string,time_t *value_return
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_i18n_get_language_list</NAME>
<RETURNS>GList 	       *</RETURNS>
const gchar *category_name
</FUNCTION>
<MACRO>
<NAME>_</NAME>
#    define _(String) dgettext (PACKAGE, String)
</MACRO>
<MACRO>
<NAME>N_</NAME>
#        define N_(String) gettext_noop (String)
</MACRO>
<MACRO>
<NAME>N_</NAME>
#        define N_(String) (String)
</MACRO>
<MACRO>
<NAME>textdomain</NAME>
#    define textdomain(String) (String)
</MACRO>
<MACRO>
<NAME>gettext</NAME>
#    define gettext(String) (String)
</MACRO>
<MACRO>
<NAME>dgettext</NAME>
#    define dgettext(Domain,Message) (Message)
</MACRO>
<MACRO>
<NAME>dcgettext</NAME>
#    define dcgettext(Domain,Message,Type) (Message)
</MACRO>
<MACRO>
<NAME>bindtextdomain</NAME>
#    define bindtextdomain(Domain,Directory) (Domain)
</MACRO>
<MACRO>
<NAME>_</NAME>
#    define _(String) (String)
</MACRO>
<MACRO>
<NAME>N_</NAME>
#    define N_(String) (String)
</MACRO>
<MACRO>
<NAME>GNOME_VFS_MODULE_DIR</NAME>
#define GNOME_VFS_MODULE_DIR     LIBDIR "/vfs/modules"
</MACRO>
<MACRO>
<NAME>GNOME_VFS_MODULE_CFGDIR</NAME>
#define GNOME_VFS_MODULE_CFGDIR  SYSCONFDIR "/vfs/modules"
</MACRO>
<FUNCTION>
<NAME>alloca</NAME>
<RETURNS>char  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>getdelim</NAME>
<RETURNS>ssize_t  </RETURNS>
char **lineptr, size_t *n, int terminator, FILE *stream
</FUNCTION>
<ENUM>
<NAME>GnomeVFSProcessResult</NAME>
enum GnomeVFSProcessResult {
	GNOME_VFS_PROCESS_OK,
	GNOME_VFS_PROCESS_ERROR_UNKNOWN,
	GNOME_VFS_PROCESS_ERROR_INVALIDSIGNAL,
	GNOME_VFS_PROCESS_ERROR_NOPERM,
	GNOME_VFS_PROCESS_ERROR_NOPROCESS
};
</ENUM>
<ENUM>
<NAME>GnomeVFSProcessRunResult</NAME>
enum GnomeVFSProcessRunResult {
	GNOME_VFS_PROCESS_RUN_OK,
	GNOME_VFS_PROCESS_RUN_ERROR,
	GNOME_VFS_PROCESS_RUN_CANCELLED,
	GNOME_VFS_PROCESS_RUN_SIGNALED,
	GNOME_VFS_PROCESS_RUN_STOPPED
};
</ENUM>
<ENUM>
<NAME>GnomeVFSProcessOptions</NAME>
enum GnomeVFSProcessOptions {
	GNOME_VFS_PROCESS_DEFAULT = 0,
	GNOME_VFS_PROCESS_USEPATH = 1 << 0,
	GNOME_VFS_PROCESS_CLOSEFDS = 1 << 1,
	GNOME_VFS_PROCESS_SETSID = 1 << 2
};
</ENUM>
<STRUCT>
<NAME>GnomeVFSProcess</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GnomeVFSProcessInitFunc</NAME>
<RETURNS>void </RETURNS>
gpointer data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeVFSProcessCallback</NAME>
<RETURNS>void </RETURNS>
GnomeVFSProcess *process,
					  gint status,
					  gpointer data
</USER_FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_process_init</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_process_new</NAME>
<RETURNS>GnomeVFSProcess  *</RETURNS>
const gchar *file_name,const gchar * const argv[],GnomeVFSProcessOptions options,GnomeVFSProcessInitFunc init_func,gpointer init_data,GnomeVFSProcessCallback callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_process_free</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSProcess *process
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_regexp_filter_new</NAME>
<RETURNS>GnomeVFSRegexpFilter  *</RETURNS>
const gchar *regexp,GnomeVFSDirectoryFilterOptionsoptions
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_regexp_filter_destroy</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSRegexpFilter *filter
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_regexp_filter_apply</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeVFSRegexpFilter *filter,GnomeVFSFileInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_result_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
GnomeVFSResult result
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_result_from_errno_code</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
int errno_code
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_result_from_errno</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_result_from_h_errno</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_seek_emulate</NAME>
<RETURNS>GnomeVFSMethodHandle  *</RETURNS>
GnomeVFSURI          *handle,GnomeVFSMethodHandle *child_handle,GnomeVFSOpenMode      open_mode
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_shellpattern_filter_new</NAME>
<RETURNS>GnomeVFSShellpatternFilter  *</RETURNS>
const gchar *pattern,GnomeVFSDirectoryFilterOptionsoptions
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_shellpattern_filter_destroy</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSShellpatternFilter*filter
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_shellpattern_filter_apply</NAME>
<RETURNS>gboolean</RETURNS>
GnomeVFSShellpatternFilter*filter,GnomeVFSFileInfo *info
</FUNCTION>
<ENUM>
<NAME>GnomeVFSResult</NAME>
typedef enum {
	GNOME_VFS_OK,
	GNOME_VFS_ERROR_NOT_FOUND,
	GNOME_VFS_ERROR_GENERIC,
	GNOME_VFS_ERROR_INTERNAL,
	GNOME_VFS_ERROR_BAD_PARAMETERS,
	GNOME_VFS_ERROR_NOT_SUPPORTED,
	GNOME_VFS_ERROR_IO,
	GNOME_VFS_ERROR_CORRUPTED_DATA,
	GNOME_VFS_ERROR_WRONG_FORMAT,
	GNOME_VFS_ERROR_BAD_FILE,
	GNOME_VFS_ERROR_TOO_BIG,
	GNOME_VFS_ERROR_NO_SPACE,
	GNOME_VFS_ERROR_READ_ONLY,
	GNOME_VFS_ERROR_INVALID_URI,
	GNOME_VFS_ERROR_NOT_OPEN,
	GNOME_VFS_ERROR_INVALID_OPEN_MODE,
	GNOME_VFS_ERROR_ACCESS_DENIED,
	GNOME_VFS_ERROR_TOO_MANY_OPEN_FILES,
	GNOME_VFS_ERROR_EOF,
	GNOME_VFS_ERROR_NOT_A_DIRECTORY,
	GNOME_VFS_ERROR_IN_PROGRESS,
	GNOME_VFS_ERROR_INTERRUPTED,
	GNOME_VFS_ERROR_FILE_EXISTS,
	GNOME_VFS_ERROR_LOOP,
	GNOME_VFS_ERROR_NOT_PERMITTED,
	GNOME_VFS_ERROR_IS_DIRECTORY,
	GNOME_VFS_ERROR_NO_MEMORY,
	GNOME_VFS_ERROR_HOST_NOT_FOUND,
	GNOME_VFS_ERROR_INVALID_HOST_NAME,
	GNOME_VFS_ERROR_HOST_HAS_NO_ADDRESS,
	GNOME_VFS_ERROR_LOGIN_FAILED,
	GNOME_VFS_ERROR_CANCELLED,
	GNOME_VFS_ERROR_DIRECTORY_BUSY,
	GNOME_VFS_ERROR_DIRECTORY_NOT_EMPTY,
	GNOME_VFS_ERROR_TOO_MANY_LINKS,
	GNOME_VFS_ERROR_READ_ONLY_FILE_SYSTEM,
	GNOME_VFS_ERROR_NOT_SAME_FILE_SYSTEM,
	GNOME_VFS_ERROR_NAME_TOO_LONG,
	GNOME_VFS_ERROR_SERVICE_NOT_AVAILABLE,
	GNOME_VFS_NUM_ERRORS
} GnomeVFSResult;
</ENUM>
<ENUM>
<NAME>GnomeVFSOpenMode</NAME>
typedef enum {
	GNOME_VFS_OPEN_NONE = 0,
	GNOME_VFS_OPEN_READ = 1 << 0,
	GNOME_VFS_OPEN_WRITE = 1 << 1,
	GNOME_VFS_OPEN_RANDOM = 1 << 2
} GnomeVFSOpenMode;
</ENUM>
<ENUM>
<NAME>GnomeVFSFileType</NAME>
typedef enum {
	GNOME_VFS_FILE_TYPE_UNKNOWN,
	GNOME_VFS_FILE_TYPE_REGULAR,
	GNOME_VFS_FILE_TYPE_DIRECTORY,
	GNOME_VFS_FILE_TYPE_FIFO,
	GNOME_VFS_FILE_TYPE_SOCKET,
	GNOME_VFS_FILE_TYPE_CHARACTER_DEVICE,
	GNOME_VFS_FILE_TYPE_BLOCK_DEVICE,
	GNOME_VFS_FILE_TYPE_SYMBOLIC_LINK
} GnomeVFSFileType;
</ENUM>
<ENUM>
<NAME>GnomeVFSFilePermissions</NAME>
typedef enum {
	GNOME_VFS_PERM_SUID = S_ISUID,
	GNOME_VFS_PERM_SGID = S_ISGID,	
	GNOME_VFS_PERM_STICKY = 01000,	/* S_ISVTX not defined on all systems */
	GNOME_VFS_PERM_USER_READ = S_IRUSR,
	GNOME_VFS_PERM_USER_WRITE = S_IWUSR,
	GNOME_VFS_PERM_USER_EXEC = S_IXUSR,
	GNOME_VFS_PERM_USER_ALL = S_IRUSR | S_IWUSR | S_IXUSR,
	GNOME_VFS_PERM_GROUP_READ = S_IRGRP,
	GNOME_VFS_PERM_GROUP_WRITE = S_IWGRP,
	GNOME_VFS_PERM_GROUP_EXEC = S_IXGRP,
	GNOME_VFS_PERM_GROUP_ALL = S_IRGRP | S_IWGRP | S_IXGRP,
	GNOME_VFS_PERM_OTHER_READ = S_IROTH,
	GNOME_VFS_PERM_OTHER_WRITE = S_IWOTH,
	GNOME_VFS_PERM_OTHER_EXEC = S_IXOTH,
	GNOME_VFS_PERM_OTHER_ALL = S_IROTH | S_IWOTH | S_IXOTH
} GnomeVFSFilePermissions;
</ENUM>
<ENUM>
<NAME>GnomeVFSSeekPosition</NAME>
typedef enum {
	GNOME_VFS_SEEK_START,
	GNOME_VFS_SEEK_CURRENT,
	GNOME_VFS_SEEK_END
} GnomeVFSSeekPosition;
</ENUM>
<TYPEDEF>
<NAME>GnomeVFSToplevelURI</NAME>
typedef struct {
	/* Base object.  */
	GnomeVFSURI uri;

	/* Server location information.  */
	gchar *host_name;
	guint host_port;

	/* Authorization information.  */
	gchar *user_name;
	gchar *password;

	/* The parent URN, if it exists */
	gchar *urn;
} GnomeVFSToplevelURI;
</TYPEDEF>
<ENUM>
<NAME>GnomeVFSURIHideOptions</NAME>
typedef enum {
	GNOME_VFS_URI_HIDE_NONE = 0,
	GNOME_VFS_URI_HIDE_USER_NAME = 1 << 0,
	GNOME_VFS_URI_HIDE_PASSWORD = 1 << 1,
	GNOME_VFS_URI_HIDE_HOST_NAME = 1 << 2,
	GNOME_VFS_URI_HIDE_HOST_PORT = 1 << 3,
	GNOME_VFS_URI_HIDE_TOPLEVEL_METHOD = 1 << 4,
	GNOME_VFS_URI_HIDE_FRAGMENT_IDENTIFIER = 1 << 8
} GnomeVFSURIHideOptions;
</ENUM>
<ENUM>
<NAME>GnomeVFSFileFlags</NAME>
typedef enum {
	GNOME_VFS_FILE_FLAGS_NONE = 0,
	/* Whether the file is a symlink.  */
	GNOME_VFS_FILE_FLAGS_SYMLINK = 1 << 0,
	/* Whether the file is on a local file system.  */
	GNOME_VFS_FILE_FLAGS_LOCAL = 1 << 1,
} GnomeVFSFileFlags;
</ENUM>
<ENUM>
<NAME>GnomeVFSFileInfoFields</NAME>
typedef enum {
	GNOME_VFS_FILE_INFO_FIELDS_NONE = 0,
	GNOME_VFS_FILE_INFO_FIELDS_TYPE = 1 << 0,
	GNOME_VFS_FILE_INFO_FIELDS_PERMISSIONS = 1 << 1,
	GNOME_VFS_FILE_INFO_FIELDS_FLAGS = 1 << 2,
	GNOME_VFS_FILE_INFO_FIELDS_DEVICE = 1 << 3,
	GNOME_VFS_FILE_INFO_FIELDS_INODE = 1 << 4,
	GNOME_VFS_FILE_INFO_FIELDS_LINK_COUNT = 1 << 5,
	GNOME_VFS_FILE_INFO_FIELDS_SIZE = 1 << 6,
	GNOME_VFS_FILE_INFO_FIELDS_BLOCK_COUNT = 1 << 7,
	GNOME_VFS_FILE_INFO_FIELDS_IO_BLOCK_SIZE = 1 << 8,
	GNOME_VFS_FILE_INFO_FIELDS_ATIME = 1 << 9,
	GNOME_VFS_FILE_INFO_FIELDS_MTIME = 1 << 10,
	GNOME_VFS_FILE_INFO_FIELDS_CTIME = 1 << 11,
	GNOME_VFS_FILE_INFO_FIELDS_SYMLINK_NAME = 1 << 12,
	GNOME_VFS_FILE_INFO_FIELDS_MIME_TYPE = 1 << 13
} GnomeVFSFileInfoFields;
</ENUM>
<TYPEDEF>
<NAME>GnomeVFSFileInfo</NAME>
typedef struct {
	/* Base name of the file (no path).  */
	gchar *name;

	/* Fields which are actually valid in this strcture. */
	GnomeVFSFileInfoFields valid_fields;

	/* File type (i.e. regular, directory, block device...).  */
	GnomeVFSFileType type;

	/* File permissions.  */
	GnomeVFSFilePermissions permissions;

	/* Flags for this file.  */
	GnomeVFSFileFlags flags;

	/* This is only valid if `is_local' is TRUE (see below).  */
	dev_t device;
	ino_t inode;

	/* Link count.  */
	guint link_count;

	/* UID, GID.  */
	guint uid;
	guint gid;

	/* Size in bytes.  */
	GnomeVFSFileSize size;

	/* Size measured in units of 512-byte blocks.  */
	GnomeVFSFileSize block_count;

	/* Optimal buffer size for reading/writing the file.  */
	guint io_block_size;

	/* Access, modification and change times.  */
	time_t atime;
	time_t mtime;
	time_t ctime;

	/* If the file is a symlink (see `flags'), this specifies the file the
           link points to.  */
	gchar *symlink_name;

	/* MIME type.  */
	gchar *mime_type;

	guint refcount;
} GnomeVFSFileInfo;
</TYPEDEF>
<ENUM>
<NAME>GnomeVFSFileInfoOptions</NAME>
typedef enum {
	GNOME_VFS_FILE_INFO_DEFAULT = 0, /* FIXME bugzilla.eazel.com 1203: name sucks */
	GNOME_VFS_FILE_INFO_GET_MIME_TYPE = 1 << 0,
	GNOME_VFS_FILE_INFO_FORCE_FAST_MIME_TYPE = 1 << 1,
	GNOME_VFS_FILE_INFO_FORCE_SLOW_MIME_TYPE = 1 << 2,
	GNOME_VFS_FILE_INFO_FOLLOW_LINKS = 1 << 3
} GnomeVFSFileInfoOptions;
</ENUM>
<ENUM>
<NAME>GnomeVFSSetFileInfoMask</NAME>
typedef enum {
	GNOME_VFS_SET_FILE_INFO_NONE = 0,
	GNOME_VFS_SET_FILE_INFO_NAME = 1 << 0,
	GNOME_VFS_SET_FILE_INFO_PERMISSIONS = 1 << 1,
	GNOME_VFS_SET_FILE_INFO_OWNER = 1 << 2,
	GNOME_VFS_SET_FILE_INFO_TIME = 1 << 3
} GnomeVFSSetFileInfoMask;
</ENUM>
<ENUM>
<NAME>GnomeVFSFindDirectoryKind</NAME>
typedef enum {
	GNOME_VFS_DIRECTORY_KIND_DESKTOP = 1000,
	GNOME_VFS_DIRECTORY_KIND_TRASH = 1001
} GnomeVFSFindDirectoryKind;
</ENUM>
<TYPEDEF>
<NAME>GnomeVFSDirectoryListPosition</NAME>
typedef gpointer GnomeVFSDirectoryListPosition;
</TYPEDEF>
<MACRO>
<NAME>GNOME_VFS_DIRECTORY_LIST_POSITION_NONE</NAME>
#define GNOME_VFS_DIRECTORY_LIST_POSITION_NONE NULL
</MACRO>
<ENUM>
<NAME>GnomeVFSDirectorySortRule</NAME>
typedef enum {
	GNOME_VFS_DIRECTORY_SORT_NONE,
	GNOME_VFS_DIRECTORY_SORT_DIRECTORYFIRST,
	GNOME_VFS_DIRECTORY_SORT_BYNAME,
	GNOME_VFS_DIRECTORY_SORT_BYNAME_IGNORECASE,
	GNOME_VFS_DIRECTORY_SORT_BYSIZE,
	GNOME_VFS_DIRECTORY_SORT_BYBLOCKCOUNT,
	GNOME_VFS_DIRECTORY_SORT_BYATIME,
	GNOME_VFS_DIRECTORY_SORT_BYMTIME,
	GNOME_VFS_DIRECTORY_SORT_BYCTIME,
	GNOME_VFS_DIRECTORY_SORT_BYMIMETYPE
} GnomeVFSDirectorySortRule;
</ENUM>
<ENUM>
<NAME>GnomeVFSDirectoryFilterType</NAME>
typedef enum {
	GNOME_VFS_DIRECTORY_FILTER_NONE,
	GNOME_VFS_DIRECTORY_FILTER_SHELLPATTERN,
	GNOME_VFS_DIRECTORY_FILTER_REGEXP
} GnomeVFSDirectoryFilterType;
</ENUM>
<ENUM>
<NAME>GnomeVFSDirectoryFilterOptions</NAME>
typedef enum {
	GNOME_VFS_DIRECTORY_FILTER_DEFAULT = 0,
	GNOME_VFS_DIRECTORY_FILTER_NODIRS = 1 << 0,
	GNOME_VFS_DIRECTORY_FILTER_DIRSONLY = 1 << 1,
	GNOME_VFS_DIRECTORY_FILTER_NODOTFILES = 1 << 2,
	GNOME_VFS_DIRECTORY_FILTER_IGNORECASE = 1 << 3,
	GNOME_VFS_DIRECTORY_FILTER_EXTENDEDREGEXP =  1 << 4,
	GNOME_VFS_DIRECTORY_FILTER_NOSELFDIR = 1 << 5,
	GNOME_VFS_DIRECTORY_FILTER_NOPARENTDIR = 1 << 6,
	GNOME_VFS_DIRECTORY_FILTER_NOBACKUPFILES = 1 << 7
} GnomeVFSDirectoryFilterOptions;
</ENUM>
<ENUM>
<NAME>GnomeVFSDirectoryFilterNeeds</NAME>
typedef enum {
	GNOME_VFS_DIRECTORY_FILTER_NEEDS_NOTHING = 0,
	GNOME_VFS_DIRECTORY_FILTER_NEEDS_NAME = 1 << 0,
	GNOME_VFS_DIRECTORY_FILTER_NEEDS_TYPE = 1 << 1,
	GNOME_VFS_DIRECTORY_FILTER_NEEDS_STAT = 1 << 2,
	GNOME_VFS_DIRECTORY_FILTER_NEEDS_MIMETYPE = 1 << 3,
} GnomeVFSDirectoryFilterNeeds;
</ENUM>
<ENUM>
<NAME>GnomeVFSDirectoryVisitOptions</NAME>
typedef enum {
	GNOME_VFS_DIRECTORY_VISIT_DEFAULT = 0,
	GNOME_VFS_DIRECTORY_VISIT_SAMEFS = 1 << 0,
	GNOME_VFS_DIRECTORY_VISIT_LOOPCHECK = 1 << 1
} GnomeVFSDirectoryVisitOptions;
</ENUM>
<USER_FUNCTION>
<NAME>GnomeVFSDirectoryFilterFunc</NAME>
<RETURNS>gboolean </RETURNS>
const GnomeVFSFileInfo *info,
						  gpointer data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeVFSDirectorySortFunc</NAME>
<RETURNS>gint </RETURNS>
const GnomeVFSFileInfo *a,
						  const GnomeVFSFileInfo *b,
						  gpointer data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeVFSDirectoryVisitFunc</NAME>
<RETURNS>gboolean </RETURNS>
const gchar *rel_path,
						  GnomeVFSFileInfo *info,
						  gboolean recursing_will_loop,
						  gpointer data,
						  gboolean *recurse
</USER_FUNCTION>
<ENUM>
<NAME>GnomeVFSXferOptions</NAME>
typedef enum {
	GNOME_VFS_XFER_DEFAULT = 0,
	GNOME_VFS_XFER_UNUSED_1 = 1 << 0,
	GNOME_VFS_XFER_FOLLOW_LINKS = 1 << 1,
	GNOME_VFS_XFER_UNUSED_2 = 1 << 2,
	GNOME_VFS_XFER_RECURSIVE = 1 << 3,
	GNOME_VFS_XFER_SAMEFS = 1 << 4,
	GNOME_VFS_XFER_DELETE_ITEMS = 1 << 5,
	GNOME_VFS_XFER_EMPTY_DIRECTORIES = 1 << 6,
	GNOME_VFS_XFER_NEW_UNIQUE_DIRECTORY = 1 << 7,
	GNOME_VFS_XFER_REMOVESOURCE = 1 << 8,
	GNOME_VFS_XFER_USE_UNIQUE_NAMES = 1 << 9,
	GNOME_VFS_XFER_LINK_ITEMS = 1 << 10
} GnomeVFSXferOptions;
</ENUM>
<ENUM>
<NAME>GnomeVFSXferProgressStatus</NAME>
typedef enum {
	GNOME_VFS_XFER_PROGRESS_STATUS_OK = 0,
	GNOME_VFS_XFER_PROGRESS_STATUS_VFSERROR = 1,
	GNOME_VFS_XFER_PROGRESS_STATUS_OVERWRITE = 2,
	/* during the duplicate status the progress callback is asked to
	   supply a new unique name */
	GNOME_VFS_XFER_PROGRESS_STATUS_DUPLICATE = 3
} GnomeVFSXferProgressStatus;
</ENUM>
<ENUM>
<NAME>GnomeVFSXferOverwriteMode</NAME>
typedef enum {
	/* Interrupt transferring with an error (GNOME_VFS_ERROR_FILEEXISTS).  */
	GNOME_VFS_XFER_OVERWRITE_MODE_ABORT = 0,
	/* Invoke the progress callback with a
	   `GNOME_VFS_XFER_PROGRESS_STATUS_OVERWRITE' status code. */
	GNOME_VFS_XFER_OVERWRITE_MODE_QUERY = 1,
	/* Overwrite files silently.  */
	GNOME_VFS_XFER_OVERWRITE_MODE_REPLACE = 2,
	/* Ignore files silently.  */
	GNOME_VFS_XFER_OVERWRITE_MODE_SKIP = 3
} GnomeVFSXferOverwriteMode;
</ENUM>
<ENUM>
<NAME>GnomeVFSXferOverwriteAction</NAME>
typedef enum {
	GNOME_VFS_XFER_OVERWRITE_ACTION_ABORT = 0,
	GNOME_VFS_XFER_OVERWRITE_ACTION_REPLACE = 1,
	GNOME_VFS_XFER_OVERWRITE_ACTION_REPLACE_ALL = 2,
	GNOME_VFS_XFER_OVERWRITE_ACTION_SKIP = 3,
	GNOME_VFS_XFER_OVERWRITE_ACTION_SKIP_ALL = 4,
} GnomeVFSXferOverwriteAction;
</ENUM>
<ENUM>
<NAME>GnomeVFSXferErrorMode</NAME>
typedef enum {
	/* Interrupt transferring with an error (code returned is code of the
           operation that has caused the error).  */
	GNOME_VFS_XFER_ERROR_MODE_ABORT = 0,
	/* Invoke the progress callback with a
	   `GNOME_VFS_XFER_PROGRESS_STATUS_VFSERROR' status code. */
	GNOME_VFS_XFER_ERROR_MODE_QUERY = 1,
} GnomeVFSXferErrorMode;
</ENUM>
<ENUM>
<NAME>GnomeVFSXferErrorAction</NAME>
typedef enum {
	/* Interrupt operation and return `GNOME_VFS_ERROR_INTERRUPTED'.  */
	GNOME_VFS_XFER_ERROR_ACTION_ABORT = 0,
	/* Try the same operation again.  */
	GNOME_VFS_XFER_ERROR_ACTION_RETRY = 1,
	/* Skip this file and continue normally.  */
	GNOME_VFS_XFER_ERROR_ACTION_SKIP = 2
} GnomeVFSXferErrorAction;
</ENUM>
<ENUM>
<NAME>GnomeVFSXferPhase</NAME>
typedef enum {
	/* Initial phase */
	GNOME_VFS_XFER_PHASE_INITIAL,
	/* Collecting file list */
	GNOME_VFS_XFER_PHASE_COLLECTING,
	/* File list collected (*) */
	GNOME_VFS_XFER_PHASE_READYTOGO,
	/* Opening source file for reading */
	GNOME_VFS_XFER_PHASE_OPENSOURCE,
	/* Creating target file for copy */
	GNOME_VFS_XFER_PHASE_OPENTARGET,
	/* Copying data from source to target (*) */
	GNOME_VFS_XFER_PHASE_COPYING,
	/* Moving file from source to target (*) */
	GNOME_VFS_XFER_PHASE_MOVING,
	/* Reading data from source file */
	GNOME_VFS_XFER_PHASE_READSOURCE,
	/* Writing data to target file */
	GNOME_VFS_XFER_PHASE_WRITETARGET,
	/* Closing source file */
	GNOME_VFS_XFER_PHASE_CLOSESOURCE,
	/* Closing target file */
	GNOME_VFS_XFER_PHASE_CLOSETARGET,
	/* Deleting source file */
	GNOME_VFS_XFER_PHASE_DELETESOURCE,
	/* Setting attributes on target file */
	GNOME_VFS_XFER_PHASE_SETATTRIBUTES,
	/* Go to the next file (*) */
	GNOME_VFS_XFER_PHASE_FILECOMPLETED,
	/* cleaning up after a move (removing source files, etc.) */
	GNOME_VFS_XFER_PHASE_CLEANUP,
	/* Operation finished (*) */
	GNOME_VFS_XFER_PHASE_COMPLETED,
	GNOME_VFS_XFER_NUM_PHASES
} GnomeVFSXferPhase;
</ENUM>
<TYPEDEF>
<NAME>GnomeVFSXferProgressInfo</NAME>
typedef struct {
	/* Progress status (see above for a description).  */
	GnomeVFSXferProgressStatus status;

	/* VFS status code.  If `status' is
           `GNOME_VFS_XFER_PROGRESS_STATUS_VFSERROR', you should look at this
           member to know what has happened.  */
	GnomeVFSResult vfs_status;

	/* Current phase in the transferring process.  */
	GnomeVFSXferPhase phase;

	/* Source URI. FIXME bugzilla.eazel.com 1206: change name? */
	gchar *source_name;

	/* Destination URI. FIXME bugzilla.eazel.com 1206: change name? */
	gchar *target_name;

	/* Index of file being copied. */
	gulong file_index;

	/* Total number of files to be copied.  */
	gulong files_total;

	/* Total number of bytes to be copied.  */
	GnomeVFSFileSize bytes_total;

	/* Total size of this file (in bytes).  */
	GnomeVFSFileSize file_size;

	/* Bytes copied for this file so far.  */
	GnomeVFSFileSize bytes_copied;

	/* Total amount of data copied from the beginning.  */
	GnomeVFSFileSize total_bytes_copied;
	
	/* Target unique name used when duplicating, etc. to avoid collisions */ 
	gchar *duplicate_name;

	/* Count used in the unique name e.g. (copy 2), etc. */
	int duplicate_count;

	gboolean top_level_item;
	/* indicates that the copied/moved/deleted item is an actual item
	 * passed in the uri list rather than one encountered by recursively
	 * traversing directories. Used by metadata copying.
	 */

} GnomeVFSXferProgressInfo;
</TYPEDEF>
<USER_FUNCTION>
<NAME>GnomeVFSXferProgressCallback</NAME>
<RETURNS>gint </RETURNS>
GnomeVFSXferProgressInfo *info,
						 gpointer data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeVFSAsyncCallback</NAME>
<RETURNS>void </RETURNS>
GnomeVFSAsyncHandle *handle,
						 GnomeVFSResult result,
						 gpointer callback_data
</USER_FUNCTION>
<TYPEDEF>
<NAME>GnomeVFSAsyncOpenCallback</NAME>
typedef GnomeVFSAsyncCallback GnomeVFSAsyncOpenCallback;
</TYPEDEF>
<TYPEDEF>
<NAME>GnomeVFSAsyncCreateCallback</NAME>
typedef GnomeVFSAsyncCallback GnomeVFSAsyncCreateCallback;
</TYPEDEF>
<TYPEDEF>
<NAME>GnomeVFSAsyncCreateAsChannelCallback</NAME>
typedef GnomeVFSAsyncOpenAsChannelCallback GnomeVFSAsyncCreateAsChannelCallback;
</TYPEDEF>
<MACRO>
<NAME>GnomeVFSAsyncCloseCallback</NAME>
#define GnomeVFSAsyncCloseCallback	GnomeVFSAsyncCallback
</MACRO>
<USER_FUNCTION>
<NAME>GnomeVFSAsyncReadCallback</NAME>
<RETURNS>void </RETURNS>
GnomeVFSAsyncHandle *handle,
						 GnomeVFSResult result,
						 gpointer buffer,
						 GnomeVFSFileSize bytes_requested,
						 GnomeVFSFileSize bytes_read,
						 gpointer callback_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeVFSAsyncWriteCallback</NAME>
<RETURNS>void </RETURNS>
GnomeVFSAsyncHandle *handle,
						 GnomeVFSResult result,
						 gconstpointer buffer,
						 GnomeVFSFileSize bytes_requested,
						 GnomeVFSFileSize bytes_written,
						 gpointer callback_data
</USER_FUNCTION>
<TYPEDEF>
<NAME>GnomeVFSGetFileInfoResult</NAME>
typedef struct {
	GnomeVFSURI *uri;
	GnomeVFSResult result;
	GnomeVFSFileInfo *file_info;
} GnomeVFSGetFileInfoResult;
</TYPEDEF>
<TYPEDEF>
<NAME>GnomeVFSFindDirectoryResult</NAME>
typedef struct {
	GnomeVFSURI *uri;
	GnomeVFSResult result;
} GnomeVFSFindDirectoryResult;
</TYPEDEF>
<USER_FUNCTION>
<NAME>GnomeVFSStatusCallback</NAME>
<RETURNS>void </RETURNS>
const gchar *message,
						 gpointer     callback_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_new</NAME>
<RETURNS>GnomeVFSURI  	     *</RETURNS>
const gchar *text_uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_ref</NAME>
<RETURNS>GnomeVFSURI  	     *</RETURNS>
GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_unref</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_append_string</NAME>
<RETURNS>GnomeVFSURI           *</RETURNS>
const GnomeVFSURI *uri,const char *path
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_append_path</NAME>
<RETURNS>GnomeVFSURI           *</RETURNS>
const GnomeVFSURI *uri,const char *path
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_append_file_name</NAME>
<RETURNS>GnomeVFSURI           *</RETURNS>
const GnomeVFSURI *uri,const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_to_string</NAME>
<RETURNS>gchar        	     *</RETURNS>
const GnomeVFSURI *uri,GnomeVFSURIHideOptions hide_options
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_dup</NAME>
<RETURNS>GnomeVFSURI  	     *</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_is_local</NAME>
<RETURNS>gboolean  </RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_has_parent</NAME>
<RETURNS>gboolean 	</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_get_parent</NAME>
<RETURNS>GnomeVFSURI 	     *</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_get_toplevel</NAME>
<RETURNS>GnomeVFSToplevelURI  *</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_get_host_name</NAME>
<RETURNS>const gchar  	    *</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_get_scheme</NAME>
<RETURNS>const gchar          *</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_get_host_port</NAME>
<RETURNS>guint  </RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_get_user_name</NAME>
<RETURNS>const gchar  	    *</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_get_password</NAME>
<RETURNS>const gchar 	    *</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_set_host_name</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSURI *uri,const gchar *host_name
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_set_host_port</NAME>
<RETURNS>void  </RETURNS>
GnomeVFSURI *uri,guint host_port
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_set_user_name</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSURI *uri,const gchar *user_name
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_set_password</NAME>
<RETURNS>void 	</RETURNS>
GnomeVFSURI *uri,const gchar *password
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_equal</NAME>
<RETURNS>gboolean 	</RETURNS>
const GnomeVFSURI *a,const GnomeVFSURI *b
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_is_parent</NAME>
<RETURNS>gboolean 	</RETURNS>
const GnomeVFSURI *parent,const GnomeVFSURI *item,gboolean recursive
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_get_path</NAME>
<RETURNS>const gchar  	    *</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_get_basename</NAME>
<RETURNS>const gchar  	    *</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_get_fragment_identifier</NAME>
<RETURNS>const gchar  	    *</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_extract_dirname</NAME>
<RETURNS>gchar  		    *</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_extract_short_name</NAME>
<RETURNS>gchar 		    *</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_extract_short_path_name</NAME>
<RETURNS>gchar 		    *</RETURNS>
const GnomeVFSURI *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_hequal</NAME>
<RETURNS>gint 	</RETURNS>
gconstpointer a,gconstpointer b
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_hash</NAME>
<RETURNS>guint 	</RETURNS>
gconstpointer p
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_list_ref</NAME>
<RETURNS>GList                *</RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_list_unref</NAME>
<RETURNS>GList                *</RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_list_copy</NAME>
<RETURNS>GList                *</RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_uri_list_free</NAME>
<RETURNS>void  </RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_format_file_size_for_display</NAME>
<RETURNS>gchar  *</RETURNS>
GnomeVFSFileSize  size
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_escape_string</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar      *string
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_escape_path_string</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar      *path
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_escape_host_and_path_string</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar      *path
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_escape_slashes</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar      *string
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_unescape_string</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar      *string,const gchar      *illegal_characters
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_unescape_string_for_display</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar      *escaped
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_local_path_from_uri</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar      *uri
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_uri_from_local_path</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar      *local_full_path
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_list_deep_free</NAME>
<RETURNS>void  </RETURNS>
GList            *list
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_get_volume_free_space</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
const GnomeVFSURI 	*vfs_uri,GnomeVFSFileSize 	*size
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_xfer_uri_list</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
const GList *source_uri_list,const GList *target_uri_list,GnomeVFSXferOptions xfer_options,GnomeVFSXferErrorMode error_mode,GnomeVFSXferOverwriteModeoverwrite_mode,GnomeVFSXferProgressCallbackprogress_callback,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_xfer_uri</NAME>
<RETURNS>GnomeVFSResult 	</RETURNS>
const GnomeVFSURI *source_uri,const GnomeVFSURI *target_uri,GnomeVFSXferOptions xfer_options,GnomeVFSXferErrorMode error_mode,GnomeVFSXferOverwriteModeoverwrite_mode,GnomeVFSXferProgressCallbackprogress_callback,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_vfs_xfer_delete_list</NAME>
<RETURNS>GnomeVFSResult  </RETURNS>
const GList *source_uri_list,GnomeVFSXferErrorMode error_mode,GnomeVFSXferOptions xfer_options,GnomeVFSXferProgressCallbackprogress_callback,gpointer data
</FUNCTION>
<MACRO>
<NAME>GNOME_VFS_SIZE_IS_UNSIGNED_LONG_LONG</NAME>
#define GNOME_VFS_SIZE_IS_UNSIGNED_LONG_LONG
</MACRO>
<MACRO>
<NAME>GNOME_VFS_OFFSET_IS_LONG_LONG</NAME>
#define GNOME_VFS_OFFSET_IS_LONG_LONG
</MACRO>
<MACRO>
<NAME>GNOME_VFS_SIZE_FORMAT_STR</NAME>
#define GNOME_VFS_SIZE_FORMAT_STR "Lu"
</MACRO>
<MACRO>
<NAME>GNOME_VFS_OFFSET_FORMAT_STR</NAME>
#define GNOME_VFS_OFFSET_FORMAT_STR "Ld"
</MACRO>
<TYPEDEF>
<NAME>GnomeVFSFileSize</NAME>
typedef unsigned long long GnomeVFSFileSize;
</TYPEDEF>
<TYPEDEF>
<NAME>GnomeVFSFileOffset</NAME>
typedef long long GnomeVFSFileOffset;
</TYPEDEF>
