<!doctype article PUBLIC "-//GNOME//DTD DocBook PNG Variant V1.0//EN" [
]>

<article id="index">
 <artheader>
   <author>
     <firstname>Ettore</firstname>
     <surname>Perazzoli</surname>
     <affiliation>
     <address>
      <email>ettore@gnu.org</email>
     </address>
     </affiliation>
   </author>
   <copyright>
     <year>1999</year>
     <holder>Free Software Foundation</holder>
   </copyright>

  <title>Writing modules for the GNOME Virtual File System</title>
  <abstract>
    <para>
      This document briefly explains how to write new modules for the
      GNOME Virtual File System.
    </para>
  </abstract>
 </artheader>
 
  <sect1 id="Introduction">
    <title>Introduction</title>

    <para>This chapter will introduce the basic concepts that are
      needed for writing GNOME Virtual File System modules.</para>

    <sect2 id="uris">
      <title>GNOME VFS URIs (Uniform Resource Indicators)</title>

      <para>The GNOME Virtual file system uses URIs similiar to the
        standard WWW URIs.  The basic difference between a VFS URI and
        WWW URI is that, while with WWW URIs you can only use a single
        protocol for accessing a certain file, with GNOME VFS URIs you
        can combine different access methods in sequence.</para>

      <para>For example, suppose you want to access file
        <filename>hello.c</filename> in a <filename>tar.gz</filename>
        file which is in turn accessible through FTP from a remote
        machine.  In order to access this file, you would need to:</para>

      <orderedlist>
        <listitem><para>Connect to the FTP site.</para></listitem>
        
        <listitem><para>Fetch the <filename>tar.gz</filename>
        file.</para></listitem>
        
        <listitem><para>Decompress the <filename>tar.gz</filename> file using
          GZIP.</para></listitem>

        <listitem><para>Extract <filename>hello.c</filename> from the resulting
          uncompressed <filename>tar</filename> file.</para></listitem>
      </orderedlist>

      <para>The GNOME Virtual File System lets you express this by
        combining the three access methods (i.e. tar, GZIP and FTP)
        into a single URI.  Access methods are combined in the URI by
        using the # character, followed by the name for the access
        method and the subpath for that specific access method.  The
        subpath can be omitted for that storage methods that do not
        need a path to retrieve the file.  (For example, a GZIP file
        always contains a single uncompressed file, so no path is
        needed to locate the uncompressed file within the GZIP file.
        But on the other hand, the TAR method requires a path to
        locate a specific file or directory.)</para>

      <para>For example, in the case we outlined above, the URI would
        look something like:</para>

      <!-- FIXME what should I use here instead of programlisting? -->
      <programlisting>

        ftp://username:password@host.net/path/to/file.tar.gz#gzip#tar/path/to/hello.c</programlisting>

      <para>Each method/subpath couple is called a ``URI element''.
      When URI elements are combined like this, each URI element uses
      the previous one to access a base resource into which it will
      look up a file, using the subpath information.  For this reason,
      we will say that each element is the ``parent'' element for the
      following one.</para>

      <para>The first URI element, the one which has no parent, is
      called the ``toplevel'' element.  It does not use the `#'
      character; instead, it uses the standard
      <filename>method://user:password@host/path</filename> common
      for WWW URIs.  This way, normal WWW URIs can be used with the
      GNOME Virtual File System.</para>

      <para>``toplevel'' elements are also special, because they let
        users specify user names, passwords and host names.</para>
    </sect2>

    <sect2>
      <title>The <classname>GnomeVFSURI</classname> type</title>

      <para>Within the GNOME Virtual File System library, URI elements
      are represented by a special type,
      <classname>GnomeVFSURI</classname>, which is meant to represent
      user-provided URIs in an optimized way.  </para>

      <para>Every <classname>GnomeVFSURI</classname> contains the
      following information:</para>

      <itemizedlist>
        <listitem><para>A reference counter</para></listitem>
      
        <listitem><para>A pointer to the parent
        <classname>GnomeVFSURI</classname> URI element.</para></listitem>
      
        <listitem><para>The subpath.</para></listitem>
      
        <listitem><para>The name of the access method.</para></listitem>
      
        <listitem><para>A pointer to a
        <classname>GnomeVFSMethod</classname> object, describing the
        access method (see below).</para></listitem>
      </itemizedlist>

    </sect2>

  </sect1>

  <sect1>
    <title>GNOME Virtual File System access method implementation</title>

    <para>In the GNOME Virtual File System, the implementations for
    all the access methods are loaded at runtime, as shared library
    modules.  The modules are loaded during parsing of the string URI:
    if the parser encounters an access method for which no
    implementation is currently loaded, it retrieves the corresponding
    library file, dynamically links it into the executable, and
    initializes it.</para>

    <para>After initialization, the module returns a special
    <classname>GnomeVFSMethod</classname> object that contains
    pointers to the various implementation functions for that specific
    method.  By storing a pointer to this object into the
    <classname>GnomeVFSURI</classname> type, the VFS library is then
    able to use these functions during for file access.</para>

    <sect2>
      <title>How file access is performed</title>

      <para>When the VFS library needs to perform some file operation,
      it performs the following steps:</para>

      <itemizedlist>

        <listitem><para>If the URI is given in textual form (i.e. as a
        string), it parses it and activates the necessary access method
        modules.</para></listitem>

        <listitem><para>It retrieves a pointer to the lowmost
        level URI element.</para></listitem>

        <listitem><para>It retrieves a pointer to the
        <classname>GnomeVFSMethod</classname> object that corresponds
        to the access method for that URI element.</para></listitem>
        
        <listitem><para>It retrieves a pointer to the implementation
        function for that operation from the
        <classname>GnomeVFSMethod</classname>object.</para></listitem>

        <listitem><para>It invokes that implementation function
        passing the pointer to the lowmost level URI
        element.</para></listitem>
        
      </itemizedlist>

      <para>Combining the access methods is always done within the
      method implementation.  If the method implementation needs to do
      some file operation on the the parent URI element, it can do so
      by simply invoking the corresponding VFS function in, by using
      the parent pointer in the <classname>GnomeVFSURI</classname>
      object. </para>

      <para>For example, suppose you have to read a simple URI like
      the following:</para>

      <!-- FIXME what should I use here instead of programlisting? -->
      <programlisting>

        file:/home/ettore/file.gz#gzip</programlisting>

      <para>In this case, the GZIP method will be invoked with a
      pointer to the <classname>GnomeVFSURI</classname> describing the
      `gzip' part; then the GZIP method will be able to read
      <filename>file.gz</filename> by just invoking the corresponding
      GNOME VFS library function on its parent, and decompress it on
      the fly. </para>

    </sect2>

  </sect1>

  <sect1>
    <title>Implementing an access method in practice</title>

    <para>Implementing a new access method is really not difficult at
    all.  This section explains how this is done.</para>

    <sect2>
      <title>Using shared libraries</title>

      <para>Every module must be compiled as a shared library (i.e. a
      <filename>.so</filename> file).</para>

      <para>The current way for accessing the right module for the
      right method is very simple, and is based on file names.  In
      practice, a module implementing access method named
      <filename>foo</filename> must be named
      <filename>libfoo.so</filename>.  For example, the module
      implementing the <filename>ftp:</filename> access method is
      called <filename>libftp.so</filename>, the module implementing
      <filename>#gzip</filename> access is called
      <filename>libgzip.so</filename> and so on.</para>

      <para>This might change in the future.</para>

    </sect2>

    <sect2>
      <title>The initialization/shutdown functions</title>

      <para>Every shared library module must provide two functions:</para>

      <programlisting role="c">

GnomeVFSMethod *vfs_module_init (void);
void vfs_module_shutdown (GnomeVFSMethod *method);</programlisting>

      <para>These are the only functions that the VFS library will
      access directly.  All the other symbols (i.e. functions and
      variables) in the module should be made static. </para>

      <para><function>vfs_module_init()</function> is called
      as soon as the module is loaded in memory.  It will have to
      return a pointer to a <classname>GnomeVFSMethod</classname>
      object that will contain the pointers to the method's
      implementation functions.  We will describe this later. </para>

      <para><function>vfs_module_shutdown</function>, instead,
      is called before the module is unloaded or the program that uses
      it dies.  This functions should:</para>

      <itemizedlist>

        <listitem><para>Deallocate all the memory allocated by the
        module.</para></listitem>

        <listitem><para>Close all the file descriptors associated with
        the module.</para></listitem>

        <listitem><para>Kill any external process spawned by the
        module.</para></listitem>

        <listitem><para>In general, make sure that any operation that
        was going on before this function was called will be
        interrupted correctly, as soon as possible and without any
        leaks.</para></listitem>

      </itemizedlist>

    </sect2>

    <sect2>
      <title>The <classname>GnomeVFSMethod</classname> object</title>

      <para>This object is contains pointers to the module
      implementation functions.</para>

      <programlisting role="c">

GnomeVFSResult (* open)              (GnomeVFSMethodHandle **method_handle_return,
                                      GnomeVFSURI *uri,
                                      GnomeVFSOpenMode mode);

GnomeVFSResult (* create)            (GnomeVFSMethodHandle **method_handle_return,
                                      GnomeVFSURI *uri,
                                      GnomeVFSOpenMode mode,
                                      gboolean exclusive,
                                      guint perm);

GnomeVFSResult (* close)             (GnomeVFSMethodHandle *method_handle);

GnomeVFSResult (* read)              (GnomeVFSMethodHandle *method_handle,
                                      gpointer buffer,
                                      GnomeVFSFileSize num_bytes,
                                      GnomeVFSFileSize *bytes_read_return);

GnomeVFSResult (* write)             (GnomeVFSMethodHandle *method_handle,
                                      gconstpointer buffer,
                                      GnomeVFSFileSize num_bytes,
                                      GnomeVFSFileSize *bytes_written_return);

GnomeVFSResult (* seek)              (GnomeVFSMethodHandle *method_handle,
                                      GnomeVFSSeekPosition  whence,
                                      GnomeVFSFileOffset    offset);

GnomeVFSResult (* tell)              (GnomeVFSMethodHandle *method_handle,
                                      GnomeVFSFileOffset *offset_return);

GnomeVFSResult (* truncate)          (GnomeVFSMethodHandle *method_handle,
                                      GnomeVFSFileSize where);

GnomeVFSResult (* open_directory)    (GnomeVFSMethodHandle **method_handle,
                                      GnomeVFSURI *uri,
                                      GnomeVFSFileInfoOptions options,
                                      const GList *meta_keys,
                                      const GnomeVFSDirectoryFilter *filter);

GnomeVFSResult (* close_directory)   (GnomeVFSMethodHandle *method_handle);

GnomeVFSResult (* read_directory)    (GnomeVFSMethodHandle *method_handle,
                                      GnomeVFSFileInfo *file_info);

GnomeVFSResult (* get_file_info)     (GnomeVFSURI *uri,
                                      GnomeVFSFileInfo *file_info,
                                      GnomeVFSFileInfoOptions options,
                                      const GList *meta_keys);

GnomeVFSResult (* get_file_info_from_handle)
				     (GnomeVFSMethodHandle *method_handle,
                                      GnomeVFSFileInfo *file_info,
                                      GnomeVFSFileInfoOptions options,
                                      const GList *meta_keys);

gboolean       (* is_local)          (const GnomeVFSURI *uri);

GnomeVFSResult (* rename)            (GnomeVFSURI *uri, const gchar *new_name);

GnomeVFSResult (* make_directory)    (GnomeVFSURI *uri, guint perm);

GnomeVFSResult (* remove_directory)  (GnomeVFSURI *uri);

GnomeVFSResult (* unlink)            (GnomeVFSURI *uri);
</programlisting>

    </sect2>

  </sect1>

  <sect1>
    <title>Basic guidelines for writing a module</title>

    <para>Writing GNOME VFS modules is easy, but there are a few
    things that you must keep in mind when hacking them:</para>

    <itemizedlist>
      <listitem><para>All of the code must be completely thread safe.
      The reason for this is that the asynchronous GNOME VFS engine
      will use threads when available; if you don't make sure that the
      code is thread-safe, every kind of weird and unexpected errors
      will happen.  As debugging these problems can be very hard, it's
      important to write the code with threads in mind right from the
      start.</para></listitem>

      <listitem><para>The code should respect the basic GNOME
      guidelines for source code indentation and
      style.</para></listitem>
    </itemizedlist>

    <sect2>
      <title>How to make the code thread safe</title>

      <para>Although it might sound scary at first, making the code
      for the modules thread safe is not complicated at all.</para>

      <para>First of all, make sure the amount of global variables is
      kept to the bare minimum.  If possible, you should avoid them at
      all cost.</para>

      <para>For those cases where globals are inevitable (such as
      caches, connection pools or things like that), you have to make
      sure every variable is properly associated with a mutex, and
      that the mutex is locked before every access to this variable
      and released afterwards.  You can also use
      <function>G_LOCK_DEFINE_STATIC</function>,
      <function>G_LOCK</function> and <function>G_UNLOCK</function>
      for this.
      </para>

      <para>Generally speaking, if you are going to dynamically
      allocate structures that are shared by more than one
      operation/file, you should provide all of them with their nice
      mutex locks.</para>

      <para>Finally, make sure mutexes are used only if they are
      available.  One way to do so is to use macros like the
      following:</para>

      <programlisting>

#ifdef G_THREADS_ENABLED
#define MUTEX_NEW()     g_mutex_new ()
#define MUTEX_FREE(a)   g_mutex_free (a)
#define MUTEX_LOCK(a)   if ((a) != NULL) g_mutex_lock (a)
#define MUTEX_UNLOCK(a) if ((a) != NULL) g_mutex_unlock (a)
#else
#define MUTEX_NEW()     NULL
#define MUTEX_FREE(a)
#define MUTEX_LOCK(a)
#define MUTEX_UNLOCK(a)
#endif
      </programlisting>

      <para><function>G_LOCK_DEFINE_STATIC</function>,
      <function>G_LOCK</function> and <function>G_UNLOCK</function> in
      GLib are always safe to use, as they are already defined to be
      nothing when thread support is not available.</para>

      <para>(Probably it would be a good idea to have something in the
      private GNOME VFS API that does this stuff for all the
      modules.)</para>

    </sect2>
  </sect1>

</article>

<!--
Local Variables:
indent-tabs-mode: nil
End:
-->
